"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateApiRequestToolConfig = exports.swaggerValidator = exports.SwaggerValidator = void 0;
exports.validateRequest = validateRequest;
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const openapi_backend_1 = __importDefault(require("openapi-backend"));
const zod_1 = require("zod");
const config_1 = require("../constants/config");
const descriptions_1 = require("../constants/descriptions");
const openapiSpec_1 = require("../utils/openapiSpec");
const validateRequestSchema = zod_1.z.object({
    body: zod_1.z.any().optional().describe("The request body, if applicable"),
    headers: zod_1.z
        .record(zod_1.z.string())
        .describe("The HTTP headers as a key-value map")
        .optional(),
    method: zod_1.z.string().min(1).describe("The HTTP method, e.g., POST, GET"),
    path: zod_1.z
        .string()
        .min(1)
        .describe("The API route, e.g., /api/v1/pa/payment_intents/create, including path parameters eg /api/v1/users/{id}"),
    query: zod_1.z
        .record(zod_1.z.string())
        .optional()
        .describe("The query parameters as a key-value map"),
    version: zod_1.z
        .string()
        .describe("The Airwallex API schema version, e.g. 2025-09-30")
        .optional()
        .default("latest"),
});
class SwaggerValidator {
    apiUrl;
    initialized = false;
    validators;
    versionToSchemaCache;
    constructor(apiUrl) {
        this.apiUrl = apiUrl;
        this.validators = new Map();
        this.versionToSchemaCache = new Map();
    }
    async init() {
        // always pull latest version
        const schema = await this.getOpenAPIV3Schema("latest");
        this.versionToSchemaCache.set("latest", schema);
        this.initialized = true;
    }
    async validateRequest(request, version = "latest") {
        if (!this.initialized) {
            await this.init();
        }
        const key = `${request.method?.toUpperCase()} ${request.path}`;
        let api;
        if (this.validators.has(version) &&
            this.validators.get(version).has(key)) {
            api = this.validators.get(version).get(key);
        }
        else {
            let swaggerDoc = this.versionToSchemaCache.get(version);
            if (!swaggerDoc) {
                // Get new swagger doc for this version and cache it
                const versionedSchema = await this.getOpenAPIV3Schema(version);
                this.versionToSchemaCache.set(version, versionedSchema);
                swaggerDoc = versionedSchema;
            }
            const tempSpec = (0, openapiSpec_1.extractMinimalSpec)(swaggerDoc, request.path, request.method);
            api = new openapi_backend_1.default({
                coerceTypes: false,
                customizeAjv: (ajv) => {
                    (0, ajv_formats_1.default)(ajv, {
                        formats: ["email", "uri", "date-time", "uuid"],
                        mode: "fast",
                    });
                    return ajv;
                },
                definition: tempSpec,
                strict: true,
                validate: true,
            });
            await api.init();
            const byVersion = this.validators.get(version) ?? new Map();
            byVersion.set(key, api);
            this.validators.set(version, byVersion);
        }
        // interpolate path params into path
        const interpolatedPath = (0, openapiSpec_1.interpolatePath)(request.path, request.params);
        request.path = interpolatedPath;
        const operation = api.matchOperation(request);
        if (!operation) {
            return {
                text: `No operation found for ${request.method} ${request.path}`,
                type: "text",
            };
        }
        const validationResult = api.validateRequest(request, operation);
        if (!validationResult.valid) {
            return {
                text: JSON.stringify({ errors: validationResult.errors, valid: validationResult.valid }, null, 2),
                type: "text",
            };
        }
        return {
            text: "Request is valid",
            type: "text",
        };
    }
    async getOpenAPIV3Schema(version) {
        const url = `${this.apiUrl}?version=${version || "latest"}`;
        const schema = await (0, openapiSpec_1.downloadSwaggerSchema)(url);
        let processedSchema = null;
        // NOTE: check if latestSchema is swagger 2.0 and convert if so
        // This is because the openapi-backend validation libary only supports openapi version 3.x
        if ("swagger" in schema && schema.swagger === "2.0") {
            processedSchema = await (0, openapiSpec_1.convertSwaggerSchemaToOpenAPI)(schema);
        }
        else {
            // Already an OpenAPI 3.0 document
            processedSchema = schema;
        }
        if (processedSchema) {
            processedSchema = (0, openapiSpec_1.fixExclusiveMinMaxFormat)(processedSchema);
        }
        return processedSchema;
    }
}
exports.SwaggerValidator = SwaggerValidator;
async function validateRequest(args) {
    const { body, headers, method, params, path, query, version } = args;
    const normalized = Object.fromEntries(Object.entries(headers ?? {}));
    const request = {
        body,
        headers: Object.fromEntries(Object.entries(normalized).map(([k, v]) => [k.toLowerCase(), v])),
        method,
        params,
        path,
        query,
    };
    return await exports.swaggerValidator.validateRequest(request, version);
}
exports.swaggerValidator = new SwaggerValidator(config_1.AIRWALLEX_API_SCHEMA_URL);
exports.validateApiRequestToolConfig = {
    annotations: {
        readOnlyHint: true,
        title: "Validate generated code that makes API requests to the Airwallex API",
    },
    description: descriptions_1.TOOL_DESCRIPTIONS.VALIDATE_REQUEST_SCHEMA,
    name: "validate_generated_code",
    parameters: validateRequestSchema,
};
