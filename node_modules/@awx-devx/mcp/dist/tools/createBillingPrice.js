"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBillingPriceToolConfig = exports.createBillingPriceSchema = void 0;
exports.executeCreateBillingPrice = executeCreateBillingPrice;
const zod_1 = require("zod");
const descriptions_1 = require("../constants/descriptions");
exports.createBillingPriceSchema = zod_1.z
    .object({
    amount: zod_1.z.number().positive("Amount must be positive"),
    currency: zod_1.z
        .string()
        .length(3, "Currency must be a 3-letter ISO-4217 code")
        .toUpperCase(),
    pricing_model: zod_1.z
        .enum(["FLAT", "PER_UNIT"], {
        errorMap: () => ({
            message: "Pricing model must be either FLAT or PER_UNIT",
        }),
    })
        .describe("PER_UNIT multiplies by quantity, FLAT does not. Prefer PER_UNIT for ONE_OFF and FLAT for RECURRING."),
    product_id: zod_1.z.string().min(1, "Product ID is required"),
    recurring_period: zod_1.z
        .number()
        .int()
        .positive("Recurring period must be a positive integer")
        .optional(),
    recurring_period_unit: zod_1.z
        .enum(["DAY", "WEEK", "MONTH", "YEAR"], {
        errorMap: () => ({
            message: "Recurring period unit must be one of: DAY, WEEK, MONTH, YEAR",
        }),
    })
        .optional(),
    type: zod_1.z.enum(["ONE_OFF", "RECURRING"], {
        errorMap: () => ({ message: "Type must be either ONE_OFF or RECURRING" }),
    }),
})
    .refine((data) => {
    if (data.type === "RECURRING") {
        return (data.recurring_period !== undefined &&
            data.recurring_period_unit !== undefined);
    }
    return true;
}, {
    message: "recurring_period and recurring_period_unit are required when type is RECURRING",
    path: ["recurring_period"],
})
    .refine((data) => {
    if (data.type === "ONE_OFF") {
        return (data.recurring_period === undefined &&
            data.recurring_period_unit === undefined);
    }
    return true;
}, {
    message: "recurring_period and recurring_period_unit must not be provided when type is ONE_OFF",
    path: ["recurring_period"],
});
async function executeCreateBillingPrice(airwallex, args) {
    try {
        const requestId = `price_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const requestBody = {
            currency: args.currency,
            pricing_model: args.pricing_model,
            product_id: args.product_id,
            request_id: requestId,
            type: args.type,
        };
        if (args.pricing_model === "FLAT") {
            requestBody.flat_amount = args.amount;
        }
        else {
            requestBody.unit_amount = args.amount;
        }
        if (args.type === "RECURRING") {
            requestBody.recurring = {
                period: args.recurring_period,
                period_unit: args.recurring_period_unit,
            };
        }
        const response = (await airwallex.post("/api/v1/prices/create", requestBody));
        return {
            text: JSON.stringify(response, null, 2),
            type: "text",
        };
    }
    catch (error) {
        const statusCode = error?.status || error?.statusCode || 500;
        const errorMessage = error?.message || "Unknown error occurred";
        throw new Error(`Failed to create billing price (${statusCode}): ${errorMessage}`);
    }
}
exports.createBillingPriceToolConfig = {
    annotations: {
        openWorldHint: false,
        readOnlyHint: false,
        title: "Create billing price",
    },
    description: descriptions_1.TOOL_DESCRIPTIONS.CREATE_BILLING_PRICE,
    name: "sandbox_create_billing_price",
    parameters: exports.createBillingPriceSchema,
};
