"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSwaggerSchemaToOpenAPI = convertSwaggerSchemaToOpenAPI;
exports.downloadSwaggerSchema = downloadSwaggerSchema;
exports.extractMinimalSpec = extractMinimalSpec;
exports.fixExclusiveMinMaxFormat = fixExclusiveMinMaxFormat;
exports.interpolatePath = interpolatePath;
const swagger2openapi_1 = __importDefault(require("swagger2openapi"));
async function convertSwaggerSchemaToOpenAPI(doc) {
    // Convert the callback-based function to a Promise
    if (!doc || typeof doc !== "object") {
        throw new Error("Invalid Swagger document: received empty or non-object response");
    }
    const converted = await new Promise((resolve, reject) => {
        swagger2openapi_1.default.convertObj(doc, { patch: true, resolveInternal: true, warnOnly: true }, (err, options) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(options);
            }
        });
    });
    return converted.openapi;
}
async function downloadSwaggerSchema(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to fetch Swagger schema: ${response.status} ${response.statusText}`);
        }
        const swaggerDoc = await response.json();
        // Validate that we received a valid document
        if (!swaggerDoc || typeof swaggerDoc !== "object") {
            throw new Error("Invalid Swagger document: received empty or non-object response");
        }
        return swaggerDoc;
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to download Swagger schema from '${url}': ${error.message}`);
        }
        throw new Error(`Failed to download Swagger schema from '${url}': Unknown error`);
    }
}
// Usage:
// const spec = fs.readFileSync('openapi.json', 'utf-8');
// const minimalSpec = extractMinimalSpec(JSON.parse(spec), '/api/v1/pa/payment_intents/create', 'POST');
// console.log(JSON.stringify(minimalSpec, null, 2));
function extractMinimalSpec(spec, path, method) {
    const components = extractReferencedComponents(spec, path, method);
    const pathItem = spec.paths[path];
    if (!pathItem) {
        throw new Error(`Path '${path}' not found in the OpenAPI spec.`);
    }
    const lowerMethod = method.toLowerCase();
    const operation = pathItem[lowerMethod];
    if (!operation) {
        throw new Error(`Method '${method}' not found for path '${path}' in the OpenAPI spec.`);
    }
    return {
        components: Object.keys(components).length > 0 ? components : undefined,
        info: spec.info,
        openapi: spec.openapi,
        paths: {
            [path]: {
                [lowerMethod]: operation,
                ...(pathItem.parameters ? { parameters: pathItem.parameters } : {}),
            },
        },
    };
}
/**
 * Fixes OpenAPI schemas by converting legacy exclusiveMinimum/exclusiveMaximum boolean (that is used in JSON Draft 4) format
 * to the Draft 7 format.
 *
 * This function is included because the json schema validator librar (AJV) used by openapi-backend no
 * longer supports Draft 4
 *
 * Conversions performed:
 * - exclusiveMinimum: true + minimum: X → exclusiveMinimum: X (removes minimum)
 * - exclusiveMinimum: false + minimum: X → minimum: X (removes exclusiveMinimum)
 * - exclusiveMaximum: true + maximum: X → exclusiveMaximum: X (removes maximum)
 * - exclusiveMaximum: false + maximum: X → maximum: X (removes exclusiveMaximum)
 *
 * @param schema - The OpenAPI schema document to fix
 * @returns A new OpenAPI schema document with corrected exclusiveMinimum/exclusiveMaximum values
 */
function fixExclusiveMinMaxFormat(schema) {
    // Deep clone the schema to avoid mutating the original
    const fixedSchema = JSON.parse(JSON.stringify(schema));
    function processObject(obj) {
        if (!obj || typeof obj !== "object") {
            return;
        }
        if (Array.isArray(obj)) {
            obj.forEach((item) => processObject(item));
            return;
        }
        // Fix exclusiveMinimum boolean format
        if (typeof obj.exclusiveMinimum === "boolean" &&
            typeof obj.minimum === "number") {
            if (obj.exclusiveMinimum === true) {
                // Convert exclusiveMinimum: true + minimum: X → exclusiveMinimum: X
                obj.exclusiveMinimum = obj.minimum;
                delete obj.minimum;
            }
            else {
                // Convert exclusiveMinimum: false + minimum: X → minimum: X (remove exclusiveMinimum)
                delete obj.exclusiveMinimum;
            }
        }
        // Fix exclusiveMaximum boolean format
        if (typeof obj.exclusiveMaximum === "boolean" &&
            typeof obj.maximum === "number") {
            if (obj.exclusiveMaximum === true) {
                // Convert exclusiveMaximum: true + maximum: X → exclusiveMaximum: X
                obj.exclusiveMaximum = obj.maximum;
                delete obj.maximum;
            }
            else {
                // Convert exclusiveMaximum: false + maximum: X → maximum: X (remove exclusiveMaximum)
                delete obj.exclusiveMaximum;
            }
        }
        // Handle edge cases where exclusiveMinimum/exclusiveMaximum is boolean but no corresponding min/max
        if (typeof obj.exclusiveMinimum === "boolean" &&
            obj.minimum === undefined) {
            console.warn(`Found exclusiveMinimum: ${obj.exclusiveMinimum} without corresponding minimum value. Removing exclusiveMinimum.`);
            delete obj.exclusiveMinimum;
        }
        if (typeof obj.exclusiveMaximum === "boolean" &&
            obj.maximum === undefined) {
            console.warn(`Found exclusiveMaximum: ${obj.exclusiveMaximum} without corresponding maximum value. Removing exclusiveMaximum.`);
            delete obj.exclusiveMaximum;
        }
        // Recursively process all properties
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                processObject(obj[key]);
            }
        }
    }
    // Process the entire schema
    processObject(fixedSchema);
    return fixedSchema;
}
function interpolatePath(path, params) {
    if (!params)
        return path;
    return path.replace(/{(.*?)}/g, (_, key) => params[key] || `{${key}}`);
}
function extractReferencedComponents(spec, path, method) {
    const extractedComponents = {};
    const visited = new Set();
    const pathItem = spec.paths[path];
    if (!pathItem) {
        throw new Error(`Path ${path} not found in spec`);
    }
    const lowerMethod = method.toLowerCase();
    const operation = pathItem[lowerMethod];
    if (!operation) {
        throw new Error(`Method ${method} not found for path ${path}`);
    }
    function processObject(obj) {
        if (!obj || typeof obj !== "object") {
            return;
        }
        if (Array.isArray(obj)) {
            obj.forEach((item) => processObject(item));
            return;
        }
        const objWithRef = obj;
        if (typeof objWithRef.$ref === "string") {
            extractRef(objWithRef.$ref);
            return;
        }
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                processObject(obj[key]);
            }
        }
    }
    function extractRef(ref) {
        if (visited.has(ref)) {
            return;
        }
        visited.add(ref);
        const refMatch = ref.match(/^#\/components\/([^/]+)\/(.+)$/);
        if (!refMatch) {
            console.warn(`Invalid $ref format: ${ref}`);
            return;
        }
        const [, componentType, componentName] = refMatch;
        // Type assertions to satisfy TS for dynamic keys
        const componentsSection = spec.components?.[componentType];
        const component = componentsSection?.[componentName];
        if (!component) {
            console.warn(`Component not found: ${ref}`);
            return;
        }
        if (!extractedComponents[componentType]) {
            extractedComponents[componentType] = {};
        }
        extractedComponents[componentType][componentName] = component;
        processObject(component);
    }
    // Process path-level parameters (shared across all methods)
    if (pathItem.parameters) {
        processObject(pathItem.parameters);
    }
    // Process the operation
    processObject(operation);
    return extractedComponents;
}
